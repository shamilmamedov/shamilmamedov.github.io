<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Robot dynamics (three different ones) | Shamil Mamedov</title> <meta name="author" content="Shamil Mamedov"/> <meta name="description" content="Shamil's professional blog "/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚛️</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://shamilmamedov.github.io/blog/2023/robot-dynamics/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Shamil&nbsp;</span>Mamedov</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Robot dynamics (three different ones)</h1> <p class="post-meta">March 30, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> </p> </header> <article class="post-content"> <p style="align: left; text-align:center;"> <img src="/assets/img/blog/robot-dynamics.png" alt="" width="40%"/> <div class="caption">A schematic representation of a two degree of freedom robot</div> </p> <p>As a roboticist, understanding robot dynamics is essential for designing fast, agile trajectories and controlling potentially unstable, complex robots. In this post, we will explore three types of robot dynamics at a high level and demonstrate how to compute them using the <a href="https://stack-of-tasks.github.io/pinocchio/">Pinocchio</a> library, which is an efficient implementation of rigid robot dynamics algorithms.</p> <h1 id="inverse-dynamics">Inverse dynamics</h1> <p>Inverse dynamics is a crucial problem in robotics, necessary for motion control systems, trajectory design, and optimization. It involves finding the forces required to produce a given acceleration in a rigid-body system that consists of bodies that do not deform or change shape during motion. To represent inverse dynamics, we can use the equation:</p> \[\tau = \mathrm{ID}(model,\ q,\ \dot q,\ \ddot q) = M(q)\ddot q + C(q, \dot q) \dot q + g (q)\] <p>Here, \(model\) is the model description of the robot that contains kinematics, which are transformations between joints, and dynamical parameters like masses of links, their inertias, and the center of mass. \(q\), \(\dot q\), \(\ddot q\) are vectors of joint positions, velocities, and accelerations, while \(\tau\) is the vector of joint torques. \(M(q)\) is the position-dependent inertia matrix, \(C(q, \dot q)\) is the matrix of Centrifugal and Coriolis forces, and \(g(q)\) is the vector of gravitational forces.</p> <p>The recursive Newton-Euler algorithm (RNEA) is the most efficient algorithm for computing inverse dynamics. It consists of two recursions: forward and backward. During the forward recursion, we calculate the velocity and acceleration of each body in the tree and the forces required to produce these accelerations. During the backward recursion, we calculate the forces transmitted across the joints from the forces acting on the bodies and the generalized forces at the joint.</p> <p>Computing inverse dynamics in Pinocchio is straightforward. The following code snippet demonstrates how to do it:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pinocchio</span> <span class="k">as</span> <span class="n">pin</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">urdf_path</span> <span class="o">=</span> <span class="sh">''</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">buildModelFromUrdf</span><span class="p">(</span><span class="n">urdf_path</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">createData</span><span class="p">()</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">randomConfiguration</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">nv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">nv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="n">tau</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">rnea</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</code></pre></div></div> <h1 id="forward-dynamics">Forward dynamics</h1> <p>Forward dynamics is the problem of finding the acceleration of a rigid-body system in response to given applied forces. It is mainly used for simulation. The equation that represents forward dynamics is:</p> \[\ddot q = \mathrm{FD}(model, q, \dot q, \tau) = M(q)^{-1}\big(\tau - C(q, \dot q)\dot q - g(q)\big)\] <p>There are two methods to calculate forward dynamics: the slow system level method and the fast propagation method. In the following two subsections, we will discuss each of them.</p> <h2 id="slow-system-level-method">Slow system level method</h2> <p>The system level method involves three steps:</p> <ol> <li>Calculate the bias force \(h(q,\dot q) = C(q, \dot q) \dot q + g(q)\);</li> <li>Calculate the inertia matrix \(M(q)\);</li> <li>Solve a system of linear equations for \(\ddot q\).</li> </ol> <p>Steps 1 and 2 can be accomplished using the inverse dynamics algorithm: \(h(q, \dot q) = \mathrm{ID}(model, q, \dot q, 0)\) and \(M(q)\) can be constructed columnwise. The composite rigid body algorithm is a more advanced and faster algorithm for computing the inertial matrix. Overall, if the inverse dynamics algorithm is implemented and the computation time is not an issue, then the system level method is a good choice for calculating forward dynamics.</p> <p>Here is an example of how to compute the slow system-level method in Pinocchio:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pinocchio</span> <span class="k">as</span> <span class="n">pin</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">urdf_path</span> <span class="o">=</span> <span class="sh">''</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">buildModelFromUrdf</span><span class="p">(</span><span class="n">urdf_path</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">createData</span><span class="p">()</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">randomConfiguration</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">nv</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">nv</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># Calculate bias force
</span><span class="n">h</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">rnea</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">nv</span><span class="p">))</span>

<span class="c1"># Calculate inertia matrix
</span><span class="n">M</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">crba</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

<span class="c1"># Solve for joint accelerations
</span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">tau</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span>
</code></pre></div></div> <h2 id="fast-propagation-method">Fast propagation method</h2> <p>The fast method for calculating the forward dynamics is based on the articulated body inertia and is known as the Articulated Body Algorithm (ABA). In contrast to the usual inertia that maps velocity to momentum, the articulated body inertia maps acceleration to force. Articulated body inertias only depend on the inertias of the individual bodies and the constraints imposed by the joints, making them functions of joint position variables and not velocity variables or various force terms.</p> <p>The ABA algorithm consists of three recursions: a forward pass, a backward pass, and a second forward pass. During the first forward pass, the algorithm computes velocities and bias terms. The backward pass calculates articulated-body inertias and bias forces. Finally, during the second forward pass, the algorithm computes the accelerations.</p> <p>Here is an example of how to compute the forward dynamics using ABA and Pinocchio:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pinocchio</span> <span class="k">as</span> <span class="n">pin</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">urdf_path</span> <span class="o">=</span> <span class="sh">''</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">buildModelFromUrdf</span><span class="p">(</span><span class="n">urdf_path</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">createData</span><span class="p">()</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">randomConfiguration</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">model</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">nv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">nv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">aba</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
</code></pre></div></div> <h1 id="hybrid-dynamics">Hybrid dynamics</h1> <p>Hybrid dynamics is a generalization of both forward and inverse dynamics. In hybrid dynamics, the forces are known at some joints, the accelerations at others, and the task is to calculate the unknown forces and accelerations. This approach is useful for introducing prescribed motions into a rigid-body system. The function that represents hybrid dynamics is:</p> \[\ddot q_{FD},\ \tau_{ID} = \mathrm{HD}(model, q, \dot q, \ddot q_{ID}, \tau_{FD})\] <p>Similar to forward dynamics, hybrid dynamics can be calculated using either the slow system-level method or the fast method, which involves a combination of the RNEA and ABA algorithms. Unfortunately, Pinocchio currently does not have a fast implementation for hybrid dynamics. However, the RNEA algorithm can still be used to compute the hybrid dynamics.</p> <p>To begin with, we can take the inverse dynamics equation:</p> \[M \ddot q = \tau - h\] <p>and split the joint acceleration vector \(\ddot q\) into two parts: \(\ddot q_{ID}\) and \(\ddot q_{FD}\), where \(\ddot q_{ID}\) represents the joint accelerations which we know, and \(\ddot q_{FD}\) represents the joint accelerations that we need to calculate. Similarly, let’s split the joint torque vector \(\tau\) into two parts: \(\tau_{ID}\) which we need to calculate and \(\tau_{FD}\) which we know. Using the split acceleration and torque vectors, we can rewrite the inverse dynamics as:</p> \[\begin{bmatrix} M_{11} &amp; M_{12} \\ M_{21} &amp; M_{22} \end{bmatrix} \begin{bmatrix} \ddot q_{ID} \\ \ddot q_{FD} \end{bmatrix} = \begin{bmatrix} \tau_{ID} \\ \tau_{FD} \end{bmatrix} - \begin{bmatrix} h_{ID} \\ h_{FD} \end{bmatrix}\] <p>Now, we can rearrange the equation so that all the unknowns are on the left-hand side, and all the knowns are on the right-hand side:</p> \[\begin{bmatrix} -1 &amp; M_{12} \\ 0 &amp; M_{22} \end{bmatrix} \begin{bmatrix} \tau_{ID} \\ \ddot q_{FD} \end{bmatrix} = \begin{bmatrix} 0 \\ \tau_{FD} \end{bmatrix} - \begin{bmatrix} M_{11}\ddot q_1 + h_{ID} \\ M_{21}\ddot q_1 + h_{FD} \end{bmatrix} = \begin{bmatrix} 0 \\ \tau_{FD} \end{bmatrix} - \begin{bmatrix} \tilde h_{ID} \\ \tilde h_{FD} \end{bmatrix}\] <p>From this final arrangement, it becomes clear that to solve hybrid dynamics, we need to perform the following steps:</p> <ol> <li>Calculate modified bias force using inverse dynamics equation: \(\tilde h = \mathrm{ID}(q, \dot q, [\ddot q_{ID}^T\ 0]^T)\)</li> <li>Calculate \(M_{22}\) (the easiest way is to compute full \(M\) and extract \(M_{22}\))</li> <li>Calculate unkonwn joint accelerations by solving \(M_{22} \ddot q_{FD} = \tau_{FD} - \tilde h_{FD}\)</li> <li>Calculate unknown joint torques \(\tau_{ID}\) via \(\tau = \tilde h + M [0 \ \ddot q_{FD}^T]^T\)</li> </ol> <p>Here is an example of how to compute the hybrid dynamics using Pinocchio:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pinocchio</span> <span class="k">as</span> <span class="n">pin</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">urdf_path</span> <span class="o">=</span> <span class="sh">''</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">buildModelFromUrdf</span><span class="p">(</span><span class="n">urdf_path</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">createData</span><span class="p">()</span>

<span class="n">n_id_joints</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">n_fd_joints</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">nv</span> <span class="o">-</span> <span class="n">n_id_joints</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">randomConfiguration</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">model</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="n">nv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">a_id</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_id_joints</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">tau_fd</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_fd_joints</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="n">a_tilde</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">vstack</span><span class="p">((</span><span class="n">a_id</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">n_fd_joints</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">h_tilde</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">rnea</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">a_tilde</span><span class="p">)</span>
<span class="n">h_fd_tilde</span> <span class="o">=</span> <span class="n">h_tilde</span><span class="p">[</span><span class="n">n_fd_joints</span><span class="p">:,:]</span>

<span class="n">M</span> <span class="o">=</span> <span class="n">pin</span><span class="p">.</span><span class="nf">crba</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
<span class="n">M22</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">n_id_joints</span><span class="p">:,</span><span class="n">n_id_joints</span><span class="p">:]</span>

<span class="n">a_fd</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">solve</span><span class="p">(</span>
	<span class="n">M22</span><span class="p">,</span> 
	<span class="n">tau_fd</span> <span class="o">-</span> <span class="n">h_fd_tilde</span>
<span class="p">)</span>
<span class="n">tau_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_tilde</span> <span class="o">+</span> <span class="n">M</span> <span class="o">@</span> <span class="n">np</span><span class="p">.</span><span class="nf">vstack</span><span class="p">((</span><span class="n">np</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">a_id</span><span class="p">),</span> <span class="n">a_fd</span><span class="p">)))[:</span><span class="n">n_id_joints</span><span class="p">,:]</span>
</code></pre></div></div> <p>In conclusion, this post only provides an introduction to the complex and vast topic of robot dynamics. To gain a deeper understanding, it is highly recommended to read Roy Featherstone’s book “<a href="https://link.springer.com/book/10.1007/978-1-4899-7560-7">Rigid Body Dynamics Algorithms</a>” and Junggon Kim’s paper “<a href="https://www.cs.cmu.edu/~junggon/tools/liegroupdynamics.pdf">Lie Group Formulation of Articulated Rigid Body Dynamics</a>”.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> &copy; Copyright 2024 Shamil Mamedov. Powered by <a href="https://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>