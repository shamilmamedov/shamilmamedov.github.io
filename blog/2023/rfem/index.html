<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Modeling deformable objects: the rigid finite element method | Shamil Mamedov</title> <meta name="author" content="Shamil Mamedov"/> <meta name="description" content="Shamil's professional blog "/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"/> <link rel="shortcut icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚛️</text></svg>"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://shamilmamedov.github.io/blog/2023/rfem/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Shamil&nbsp;</span>Mamedov</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Modeling deformable objects: the rigid finite element method</h1> <p class="post-meta">March 1, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> </p> </header> <article class="post-content"> <p style="align: left; text-align:center;"> <img src="/assets/img/blog/rfem_comparison.gif" alt="" width="65%"/> </p> <p>The robotics community has shown significant interest in deformable object manipulation in recent years, with workshops hosted at <a href="https://deformable-workshop.github.io/icra2022/">ICRA</a> and <a href="https://romado-workshop.github.io/ROMADO2022/">IROS</a> in 2022. Both model-based and model-free approaches rely on accurate simulators. The finite element method (FEM), a powerful tool from continuum mechanics, can be computationally expensive for control. <a href="https://books.google.de/books?id=PhD8FDAzNJEC&amp;printsec=frontcover&amp;source=gbs_book_other_versions_r&amp;redir_esc=y#v=onepage&amp;q&amp;f=false">The rigid finite element method</a> (RFEM) is a simpler and faster approach that can leverage existing rigid-body dynamics tools.</p> <p>While not a new method, the RFEM — also known as the extended-flexible joint method or pseudo-rigid body method — remains a valuable modeling technique in robotics. This post explores its basic principles, limitations, and trade-offs, and provides a practical tutorial on simulating simple deformable linear object in Python using the <a href="https://stack-of-tasks.github.io/pinocchio/">Pinocchio</a> library.</p> <p>Whether you’re a seasoned researcher or new to the field, this post offers valuable insights and practical guidance on using the RFEM to model deformable linear objects.</p> <h1 id="basics-of-the-rfem">Basics of the RFEM</h1> <p>RFEM is a pretty straightforward way to study deformable objects by dividing them into smaller parts called rigid finite elements (rfes) and connecting them with spring-damping elements (sde). The technique uses generalised coordinates based on the elements’ displacements to describe the position of the system.</p> <p>To make things clearer, let’s consider a simple example of a cylindrical rod attached to a motor, as you an see in Figure 1. This setup can be thought of as an elastic pendulum or a deformable linear object that is manipulated by a robot arm. For now, we will only talk about dominant bending flexibility and describe the displacements of each rfe relative to the preceding element.</p> <p style="align: left; text-align:center;"> <img src="/assets/img/blog/RFEM_orig.png" alt="" width="50%"/> <div class="caption">Figure 1. Deformable linear object toy setup</div> </p> <p>The RFEM discretizes in two stages:</p> <ol> <li>Primary division: dividing the deformable object of length \(L\) into relatively simple elements with finite dimension \(\Delta l\) and concentrating their spring and damping features at one point (see Figure 2a);</li> <li>Secondary division: isolating rfes between sdes from the primary division to obtain a system of rfes connected by sdes (see Figure 2b).</li> </ol> <p style="align: left; text-align:center;"> <img src="/assets/img/blog/RFEM_discr.png" alt="" width="55%"/> <div class="caption">Figure 2. Visualization of the RFEM discretization</div> </p> <p>After discretization, we can treat the system as a serial chain of rigid bodies and derive its dynamics using the Lagrange or the Newton-Euler methods. To illustrate the general form of the RFEM dynamics, let’s briefly go through the dynamics derivation using the Lagrange method. Let \(q = [q_a\ q_p]^T\) denote the vector of joint angles, with \(q_a\) being the active joint angle and \(q_p\) being the passive joint angles of sdes. Using generalized coordinates, we can write down the energy functions used in the Lagrangian method</p> \[K(q, \dot q) = \frac{1}{2}\dot q^T M(q) \dot q,\ P(q) = \frac{1}{2} q^T K q + \sum_{i=0}^{n_s + 1} m_i g_0 p_{C_i}, \ D(\dot q) = \frac{1}{2}\dot q^T D \dot q.\] <p>Here \(n_s\) is the number of segments, \(M(q)\) is the inertia matrix, \(K\) and \(D\) are the constant diagonal stiffness and damping matrices, respectively; \(m_i\) and \(p_{C_i}\) are \(i-\)the rfes mass and the center of mass, respectively; \(g_0 = [0\ 0\ -9.81]^T\) is the gravity acceleration vector. Applying the Lagrange equations</p> \[\frac{d}{dt}\left(\frac{\partial \mathcal{L}}{\partial \dot q} \right) - \frac{\partial \mathcal{L}}{\partial q} = - \frac{\partial D}{\partial \dot q}\] <p>with \(\mathcal{L} = K - P\) being the Lagrangian, we get the final expression for the RFEM dynamics:</p> \[M(q) \ddot{q} + C(q, \dot{q}) \dot{q} + K q + D \dot{q} + g(q) = B \tau \tag{*}\] <p>Comparing the final expression for RFEM dynamics to classical rigid-body manipulator dynamics, we see two new terms: \(Kq\) representing linear spring forces and \(D\dot q\) representing linear damper forces. Despite these new terms, the difference between RFEM dynamics and classical rigid-body dynamics is minor. Therefore, we can adapt existing efficient rigid-body algorithms to compute RFEM dynamics, and there is no need to implement new software.</p> <p>For simulation and control we often need state-space models. To convert the RFEM dynamics (*) to state-space form, we define a state vector \(x=[q\ \dot q]^T\) and input \(u:= \tau\):</p> \[\dot x = f(x, u) = \begin{bmatrix} \dot q \\ M(q)^{-1} (B\tau - C(q, \dot{q}) \dot{q} - K q - D \dot{q} - g(q)) \end{bmatrix} .\] <h1 id="parameters-of-rfes-and-sdes">Parameters of rfes and sdes</h1> <p>The mass \(m_i\), first moment of inertia \(h=m_i p_{C_i}\), and second moments of inertia \(I_i\) expressed in the frame located at the center of mass of an rfe are the fundamental parameters of the rfe. In the case of homogenous (constant density \(\rho\)) objects with constant cross-section, these inertial parameters can be calculated using standard formulas. For our toy example — for a homogenous cylicrical shape rfe with length \(l\) and diameter \(d\) (as in Figure 3) — formulae are:</p> \[m = \rho \frac {\pi d^2 l}{4},\ p_C = \left[\frac{l}{2}\ 0\ 0 \right]^T,\ I_{XX} = \frac{md^2}{8},\ I_{YY} = I_{ZZ} = \frac{m}{48}(3d^2 + 4l^2)\] <p>However, for deformable objects with varying cross-sections and more complex shapes, CAD software is required.</p> <p style="align: left; text-align:center;"> <img src="/assets/img/blog/RFEM_rfe.png" alt="" width="17%"/> <div class="caption">Figure 3. Cylindrical rfe</div> </p> <p>Linear spring and damping parameters are the basic parameters of the sde. The stiffness \(k_i\) of the spring is a three-dimensional diagonal matrix, while for the planar case, \(k_i\) is a scalar. Similarly, the damping parameters \(d_i\) also follow the same rule.</p> <p>The coefficients of stiffness and damping of the sde are based on the elasticity features of a beam segment with length \(\Delta l\), such that the real segment of the beam will deform in the same way and with the same velocities of deformation as the equivalent sde under the same load. For homogenous materials of a specific constant cross-section, there are readily available formulas to calculate these coefficients. For our toy example, formulae are</p> \[k_{XX} = G\frac{\pi d^4}{32 l},\ k_{YY} = k_{ZZ} = E\frac{\pi d^4}{64l}\] <p>where \(G\) is the shear modulus and \(E\) is Young’s modulus. However, for more complex shapes, CAD software must be utilized.</p> <h1 id="tutorial-implementing-the-rfem-with-pinocchio-to-simulate-flexible-pendulum">Tutorial: implementing the RFEM with Pinocchio to simulate flexible pendulum</h1> <p>The tutorial leverages Pinocchio, an amazing tool for robot dynamics! Developed by Justin Carpentier, Pinocchio implements Roy Featherstone algorithms in C++, making it incredibly efficient. But that’s not all - it’s also been extended with new algorithms for computing derivatives of dynamics algorithms, constrained dynamics, and more. The best part? You can generate dynamics algorithms as a Casadi function and use them in optimal controller design.</p> <p>In this tutorial (<a href="https://github.com/shamilmamedov/rfem">link to code</a>), we will define the setup using URDF, which supports geometry and inertial parameters but unfortunately doesn’t support joint elasticity. Therefore, we will use an additional <code class="language-plaintext highlighter-rouge">.yaml</code> file to define sde parameters. To modify the geometry and inertial parameters of the RFEM, you will need to manually update the URDF files. But it’s easy to modify sde parameters (which is the most fun part) from the <code class="language-plaintext highlighter-rouge">rod_params.py</code> file by changing the \(G\) and \(E\) values. You can even use this file to compute the inertial parameters for a desired cylindrical rod.</p> <h2 id="computing-dynamics">Computing dynamics</h2> <p>Now, to simulate the flexible pendulum, we need to compute the forward dynamics of the RFEM model. The most efficient algorithm to use for this is articulated rigid body (ABA). Unfortunately, ABA in Pinocchio doesn’t support flexible joints (sdes) by default. But fear not, we can restructure the RFEM dynamics equation to treat sde torques as an input to the system</p> \[M(q) \ddot{q} + C(q, \dot{q}) \dot{q} + g(q) = \tilde \tau\] <p>where \(\tilde \tau = B \tau - K q - D \dot{q}\). This is possible because sde joints are virtual and are not actuated.</p> <p>To implement the flexible pendulum model, I have created a <code class="language-plaintext highlighter-rouge">FlexiblePendulum</code> class in the <code class="language-plaintext highlighter-rouge">flexible_pendulum.py</code> module. This class takes the number of segments as input and builds the model in its <code class="language-plaintext highlighter-rouge">__init__</code> method. Additionally, the class contains several other useful methods:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">elasticity_torques</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dq</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> Computes torques due to elastic elements in the
    joints: spring-damper elements
    NOTE the first joint -- active joint -- doesn</span><span class="sh">'</span><span class="s">t
         have spring-damper element in it

    :param q: joint positions
    :param dq: joint velocities

    :return: torques 
    </span><span class="sh">"""</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">self</span><span class="p">.</span><span class="n">K</span> <span class="o">@</span> <span class="n">q</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">D</span> <span class="o">@</span> <span class="n">dq</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">forward_dynamics</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span><span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dq</span><span class="p">:</span><span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tau_a</span><span class="p">:</span><span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> Computes forward dynamics

    :param q: joint positions
    :param dq: joint velocities
    :param tau_a: active joints torque

    :return: ddq -- aceelerations of all joints, active and passive 
    </span><span class="sh">"""</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">B</span> <span class="o">@</span> <span class="n">tau_a</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">elasticity_torques</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dq</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pin</span><span class="p">.</span><span class="nf">aba</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">model</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dq</span><span class="p">,</span> <span class="n">tau</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ode</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> Computes ode of the robot

    :param x: robot state
    :param u: active joint torque

    :return: x_dot
    </span><span class="sh">"""</span>
    <span class="n">q</span><span class="p">,</span> <span class="n">dq</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">vstack</span><span class="p">((</span><span class="n">dq</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="nf">forward_dynamics</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dq</span><span class="p">,</span> <span class="n">u</span><span class="p">)))</span>
</code></pre></div></div> <h2 id="integrating-rfem-dynamics">Integrating RFEM dynamics</h2> <p>It’s important to note that RFE dynamics can be quite <a href="https://en.wikipedia.org/wiki/Stiff_equation">stiff</a>, and using fixed-step integrators can result in divergence if the step size is too large. To avoid this problem, I have opted to use a variable step Runge-Kutta integrator from the <code class="language-plaintext highlighter-rouge">scipy.integrate</code> package in this tutorial.</p> <p>In order to simulate the flexible pendulum system, I have implemented a <code class="language-plaintext highlighter-rouge">simulate_flexible_pendulum</code> function in the <code class="language-plaintext highlighter-rouge">simulation.py</code> module. Additionally, to incorporate a controller into the simulation, I created a <code class="language-plaintext highlighter-rouge">controllers.py</code> file which contains an abstract <code class="language-plaintext highlighter-rouge">BaseController</code> class. To provide concrete implementations of controllers, I created a <code class="language-plaintext highlighter-rouge">DummyController</code> class that always returns zero torque, and a <code class="language-plaintext highlighter-rouge">PDController</code> that implements a proportional-derivative controller. By inheriting from the <code class="language-plaintext highlighter-rouge">BaseController</code> class, it is easy to create new controllers as needed.</p> <p>By using the variable step integrator and implementing controllers, we can now simulate the flexible pendulum system and explore its behavior under various conditions.</p> <h2 id="visualization">Visualization</h2> <p>Pinocchio provides several options for visualizing robots. In order to visualize the motion of the flexible pendulum system, I have implemented visualize_elastic_pendulum function in the <code class="language-plaintext highlighter-rouge">visualization.py</code> module which can use either the Meshcat or Panda3d visualizers of Pinocchio.</p> <h2 id="some-simulation-results">Some simulation results</h2> <p>When using RFEM to model deformable objects, the accuracy is greatly influenced by the level of discretization. Specifically, the approximation of natural frequency of the continuum material is impacted. As with any discretization method, increasing the level of discretization improves the accuracy of the approximation.</p> <p>To demonstrate this visually, let’s analyze the motion of a pendulum using three different discretizations: models with 3, 5, and 10 segments. If you’re interested in a more quantitative analysis, please refer to <a href="https://arxiv.org/abs/2212.02941">preprint of our paper</a> or <a href="https://books.google.de/books?id=PhD8FDAzNJEC&amp;printsec=frontcover&amp;source=gbs_book_other_versions_r&amp;redir_esc=y#v=onepage&amp;q&amp;f=false">the RFEM book</a>.</p> <p>We’ll use a PD controller with a zero reference for the active angle \(q_a^r = 0\) rad for 2.5 seconds, then change the reference to \(q_a^r = \pi/4\) rad for the next 2.5 seconds. The GIF below visualizes the motion of all three models. While there may be small synchronization errors, there is a noticeable difference: the model with 3 segments behaves differently compared to the models with 5 and 10 segments, which move similarly.</p> <p style="align: left; text-align:center;"> <img src="/assets/img/blog/rfem_comparison.gif" alt="" width="65%"/> </p> <h2 id="final-comments-and-recommendations">Final comments and recommendations</h2> <p>If you clone the code and run <code class="language-plaintext highlighter-rouge">main.py</code> with a 10-segment discretization, you’ll notice that the integration is quite slow. This is due to two reasons: (i) the <code class="language-plaintext highlighter-rouge">scipy</code> implementation of RK45 is inefficient and (ii) the state-space dimension is simply too large. In the past, I used the <a href="https://computing.llnl.gov/projects/sundials/cvodes">CVODES</a> integrator, which resulted in a much faster simulation time. Alternatively, fixed-step implicit integrators are a good choice for optimization-based control.</p> <p>Overall, the RFEM method is a straightforward way to model deformable objects, and it can make use of existing tools for modeling rigid robots. However, one of its main limitations is that it requires very fine discretization to accurately model deformable objects, which can result in slow computation times.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> &copy; Copyright 2024 Shamil Mamedov. Powered by <a href="https://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>